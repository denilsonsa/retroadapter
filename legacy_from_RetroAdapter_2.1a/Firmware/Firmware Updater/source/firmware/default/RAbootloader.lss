
RAbootloader.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800100  00003fae  00000842  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000007ae  00003800  00003800  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000031  0080010a  0080010a  0000084c  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  0000084c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000177  00000000  00000000  0000086c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000c4b  00000000  00000000  000009e3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000002eb  00000000  00000000  0000162e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000005ea  00000000  00000000  00001919  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000020  00000000  00000000  00001f04  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000047a  00000000  00000000  00001f24  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000004a8  00000000  00000000  0000239e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000218  00000000  00000000  00002846  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00003800 <__vectors>:
    3800:	0c 94 75 1c 	jmp	0x38ea	; 0x38ea <__ctors_end>
    3804:	0c 94 88 1e 	jmp	0x3d10	; 0x3d10 <__vector_1>
    3808:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    380c:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3810:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3814:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3818:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    381c:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3820:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3824:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3828:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    382c:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3830:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3834:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3838:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    383c:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3840:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3844:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3848:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    384c:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3850:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3854:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3858:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    385c:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3860:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>
    3864:	0c 94 92 1c 	jmp	0x3924	; 0x3924 <__bad_interrupt>

00003868 <usbDescriptorString0>:
    3868:	04 03 09 04                                         ....

0000386c <usbDescriptorStringVendor>:
    386c:	0a 03 4d 00 6f 00 4a 00 6f 00                       ..M.o.J.o.

00003876 <usbDescriptorStringDevice>:
    3876:	1e 03 52 00 41 00 20 00 55 00 70 00 64 00 61 00     ..R.A. .U.p.d.a.
    3886:	74 00 65 00 20 00 4d 00 6f 00 64 00 65 00           t.e. .M.o.d.e.

00003894 <usbDescriptorDevice>:
    3894:	12 01 10 01 00 00 00 08 82 82 01 23 00 01 01 02     ...........#....
    38a4:	00 01                                               ..

000038a6 <usbDescriptorConfiguration>:
    38a6:	09 02 22 00 01 01 00 80 32 09 04 00 00 01 03 00     ..".....2.......
    38b6:	00 00 09 21 01 01 00 01 22 21 00 07 05 81 03 08     ...!...."!......
    38c6:	00 c8                                               ..

000038c8 <usbDescriptorHidReport>:
    38c8:	06 00 ff 09 01 a1 01 15 00 26 ff 00 75 08 85 01     .........&..u...
    38d8:	95 06 09 00 b2 02 01 85 02 95 83 09 00 b2 02 01     ................
    38e8:	c0 00                                               ..

000038ea <__ctors_end>:
    38ea:	11 24       	eor	r1, r1
    38ec:	1f be       	out	0x3f, r1	; 63
    38ee:	cf ef       	ldi	r28, 0xFF	; 255
    38f0:	d4 e0       	ldi	r29, 0x04	; 4
    38f2:	de bf       	out	0x3e, r29	; 62
    38f4:	cd bf       	out	0x3d, r28	; 61

000038f6 <__do_copy_data>:
    38f6:	11 e0       	ldi	r17, 0x01	; 1
    38f8:	a0 e0       	ldi	r26, 0x00	; 0
    38fa:	b1 e0       	ldi	r27, 0x01	; 1
    38fc:	ee ea       	ldi	r30, 0xAE	; 174
    38fe:	ff e3       	ldi	r31, 0x3F	; 63
    3900:	02 c0       	rjmp	.+4      	; 0x3906 <.do_copy_data_start>

00003902 <.do_copy_data_loop>:
    3902:	05 90       	lpm	r0, Z+
    3904:	0d 92       	st	X+, r0

00003906 <.do_copy_data_start>:
    3906:	aa 30       	cpi	r26, 0x0A	; 10
    3908:	b1 07       	cpc	r27, r17
    390a:	d9 f7       	brne	.-10     	; 0x3902 <.do_copy_data_loop>

0000390c <__do_clear_bss>:
    390c:	11 e0       	ldi	r17, 0x01	; 1
    390e:	aa e0       	ldi	r26, 0x0A	; 10
    3910:	b1 e0       	ldi	r27, 0x01	; 1
    3912:	01 c0       	rjmp	.+2      	; 0x3916 <.do_clear_bss_start>

00003914 <.do_clear_bss_loop>:
    3914:	1d 92       	st	X+, r1

00003916 <.do_clear_bss_start>:
    3916:	ab 33       	cpi	r26, 0x3B	; 59
    3918:	b1 07       	cpc	r27, r17
    391a:	e1 f7       	brne	.-8      	; 0x3914 <.do_clear_bss_loop>
    391c:	0e 94 94 1c 	call	0x3928	; 0x3928 <main>
    3920:	0c 94 d5 1f 	jmp	0x3faa	; 0x3faa <_exit>

00003924 <__bad_interrupt>:
    3924:	0c 94 00 1c 	jmp	0x3800	; 0x3800 <__vectors>

00003928 <main>:
    usbDeviceConnect();
    sei();
}

int main(void)
{
    3928:	2f 92       	push	r2
    392a:	3f 92       	push	r3
    392c:	4f 92       	push	r4
    392e:	5f 92       	push	r5
    3930:	6f 92       	push	r6
    3932:	7f 92       	push	r7
    3934:	8f 92       	push	r8
    3936:	9f 92       	push	r9
    3938:	af 92       	push	r10
    393a:	bf 92       	push	r11
    393c:	cf 92       	push	r12
    393e:	df 92       	push	r13
    3940:	ef 92       	push	r14
    3942:	ff 92       	push	r15
    3944:	0f 93       	push	r16
    3946:	1f 93       	push	r17
    3948:	cf 93       	push	r28
    394a:	df 93       	push	r29
#ifndef __ASSEMBLER__   /* assembler cannot parse function definitions */
#include <util/delay.h>

static inline void  bootLoaderInit(void)
{
	DDRD	&= ~(1<<6);		// DB9 Button 1 input
    394c:	56 98       	cbi	0x0a, 6	; 10
    PORTD	|= (1<<6);		// pull up
    394e:	5e 9a       	sbi	0x0b, 6	; 11

	DDRC	&= ~(1<<0);		// Neo Geo A input
    3950:	38 98       	cbi	0x07, 0	; 7
	PORTC	|= (1<<0);		// pull up
    3952:	40 9a       	sbi	0x08, 0	; 8
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3954:	82 e3       	ldi	r24, 0x32	; 50
    3956:	8a 95       	dec	r24
    3958:	f1 f7       	brne	.-4      	; 0x3956 <main+0x2e>
    /* initialize hardware */
    bootLoaderInit();
    //odDebugInit();
    //DBG1(0x00, 0, 0);
    /* jump to application if jumper is set */
    if(bootLoaderCondition()){
    395a:	4e 9b       	sbis	0x09, 6	; 9
    395c:	02 c0       	rjmp	.+4      	; 0x3962 <main+0x3a>
    395e:	30 99       	sbic	0x06, 0	; 6
    3960:	a6 c1       	rjmp	.+844    	; 0x3cae <main+0x386>
        uchar i = 0, j = 0;
#ifndef TEST_MODE
        GICR = (1 << IVCE);  /* enable change of interrupt vectors */
    3962:	81 e0       	ldi	r24, 0x01	; 1
    3964:	85 bf       	out	0x35, r24	; 53
        GICR = (1 << IVSEL); /* move interrupts to boot flash section */
    3966:	82 e0       	ldi	r24, 0x02	; 2
    3968:	85 bf       	out	0x35, r24	; 53
/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbInit(void)
{
#if USB_INTR_CFG_SET != 0
    USB_INTR_CFG |= USB_INTR_CFG_SET;
    396a:	80 91 69 00 	lds	r24, 0x0069
    396e:	83 60       	ori	r24, 0x03	; 3
    3970:	80 93 69 00 	sts	0x0069, r24
#endif
#if USB_INTR_CFG_CLR != 0
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
    3974:	e8 9a       	sbi	0x1d, 0	; 29
#if F_CPU == 12800000
    TCCR0 = 3;          /* 1/64 prescaler */
#endif
    usbInit();
    /* enforce USB re-enumerate: */
    usbDeviceDisconnect();  /* do this while interrupts are disabled */
    3976:	51 9a       	sbi	0x0a, 1	; 10
    3978:	20 e0       	ldi	r18, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    397a:	46 ea       	ldi	r20, 0xA6	; 166
    397c:	5e e0       	ldi	r21, 0x0E	; 14
    397e:	ca 01       	movw	r24, r20
    3980:	01 97       	sbiw	r24, 0x01	; 1
    3982:	f1 f7       	brne	.-4      	; 0x3980 <main+0x58>
    do{             /* fake USB disconnect for > 250 ms */
        //wdt_reset();
        _delay_ms(1);
    }while(--i);
    3984:	21 50       	subi	r18, 0x01	; 1
    3986:	d9 f7       	brne	.-10     	; 0x397e <main+0x56>
    usbDeviceConnect();
    3988:	51 98       	cbi	0x0a, 1	; 10
    sei();
    398a:	78 94       	sei
    398c:	ff 24       	eor	r15, r15
    398e:	00 e0       	ldi	r16, 0x00	; 0
            sei();
            boot_spm_busy_wait();       /* wait until page is erased */
#endif
        }
        cli();
        boot_page_fill(address.l, *(short *)data);
    3990:	ee 24       	eor	r14, r14
    3992:	e3 94       	inc	r14
            }
        SWITCH_END
#endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
#if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
    SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
    3994:	c8 eb       	ldi	r28, 0xB8	; 184
    3996:	d8 e3       	ldi	r29, 0x38	; 56
        SWITCH_CASE(0)
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
        SWITCH_CASE(1)
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
        SWITCH_CASE(2)
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
    3998:	56 e7       	ldi	r21, 0x76	; 118
    399a:	45 2e       	mov	r4, r21
    399c:	58 e3       	ldi	r21, 0x38	; 56
    399e:	55 2e       	mov	r5, r21
#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
        SWITCH_START(rq->wValue.bytes[0])
        SWITCH_CASE(0)
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
        SWITCH_CASE(1)
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
    39a0:	4c e6       	ldi	r20, 0x6C	; 108
    39a2:	24 2e       	mov	r2, r20
    39a4:	48 e3       	ldi	r20, 0x38	; 56
    39a6:	34 2e       	mov	r3, r20
            flags = 0;
        len = usbFunctionDescriptor(rq);
#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
        SWITCH_START(rq->wValue.bytes[0])
        SWITCH_CASE(0)
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
    39a8:	38 e6       	ldi	r19, 0x68	; 104
    39aa:	a3 2e       	mov	r10, r19
    39ac:	38 e3       	ldi	r19, 0x38	; 56
    39ae:	b3 2e       	mov	r11, r19

    SWITCH_START(rq->wValue.bytes[1])
    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
    SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
    39b0:	2e ee       	ldi	r18, 0xEE	; 238
    39b2:	82 2e       	mov	r8, r18
    39b4:	2f ef       	ldi	r18, 0xFF	; 255
    39b6:	92 2e       	mov	r9, r18
    39b8:	8c 0e       	add	r8, r28
    39ba:	9d 1e       	adc	r9, r29
usbMsgLen_t len = 0;
uchar       flags = USB_FLG_MSGPTR_IS_ROM;

    SWITCH_START(rq->wValue.bytes[1])
    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
    39bc:	94 e9       	ldi	r25, 0x94	; 148
    39be:	69 2e       	mov	r6, r25
    39c0:	98 e3       	ldi	r25, 0x38	; 56
    39c2:	79 2e       	mov	r7, r25
        else{
            exitMainloop = 1;
        }
#endif
    }else if(rq->bRequest == USBRQ_HID_GET_REPORT){
        usbMsgPtr = replyBuffer;
    39c4:	82 e0       	ldi	r24, 0x02	; 2
    39c6:	c8 2e       	mov	r12, r24
    39c8:	81 e0       	ldi	r24, 0x01	; 1
    39ca:	d8 2e       	mov	r13, r24
USB_PUBLIC void usbPoll(void)
{
schar   len;
uchar   i;

    len = usbRxLen - 3;
    39cc:	90 91 21 01 	lds	r25, 0x0121
    39d0:	29 2f       	mov	r18, r25
    39d2:	23 50       	subi	r18, 0x03	; 3
    if(len >= 0){
    39d4:	27 fd       	sbrc	r18, 7
    39d6:	08 c1       	rjmp	.+528    	; 0x3be8 <main+0x2c0>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
    39d8:	80 91 1e 01 	lds	r24, 0x011E
    39dc:	ac e0       	ldi	r26, 0x0C	; 12
    39de:	b0 e0       	ldi	r27, 0x00	; 0
    39e0:	a8 1b       	sub	r26, r24
    39e2:	b1 09       	sbc	r27, r1
    39e4:	ab 5d       	subi	r26, 0xDB	; 219
    39e6:	be 4f       	sbci	r27, 0xFE	; 254
    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
        usbFunctionWriteOut(data, len);
        return;
    }
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
    39e8:	80 91 1d 01 	lds	r24, 0x011D
    39ec:	8d 32       	cpi	r24, 0x2D	; 45
    39ee:	09 f0       	breq	.+2      	; 0x39f2 <main+0xca>
    39f0:	ac c0       	rjmp	.+344    	; 0x3b4a <main+0x222>
        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
    39f2:	28 30       	cpi	r18, 0x08	; 8
    39f4:	09 f0       	breq	.+2      	; 0x39f8 <main+0xd0>
    39f6:	f6 c0       	rjmp	.+492    	; 0x3be4 <main+0x2bc>
            return;
        usbMsgLen_t replyLen;
        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
    39f8:	83 ec       	ldi	r24, 0xC3	; 195
    39fa:	80 93 11 01 	sts	0x0111, r24
        usbTxLen = USBPID_NAK;              /* abort pending transmit */
    39fe:	9a e5       	ldi	r25, 0x5A	; 90
    3a00:	90 93 00 01 	sts	0x0100, r25
        usbMsgFlags = 0;
    3a04:	10 92 0a 01 	sts	0x010A, r1
        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
    3a08:	2c 91       	ld	r18, X
        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
    3a0a:	82 2f       	mov	r24, r18
    3a0c:	80 76       	andi	r24, 0x60	; 96
    3a0e:	11 96       	adiw	r26, 0x01	; 1
    3a10:	9c 91       	ld	r25, X
    3a12:	11 97       	sbiw	r26, 0x01	; 1
    3a14:	88 23       	and	r24, r24
    3a16:	d1 f0       	breq	.+52     	; 0x3a4c <main+0x124>
        (((long)FLASHEND + 1) >> 8) & 0xff,
        (((long)FLASHEND + 1) >> 16) & 0xff,
        (((long)FLASHEND + 1) >> 24) & 0xff
    };

    if(rq->bRequest == USBRQ_HID_SET_REPORT){
    3a18:	99 30       	cpi	r25, 0x09	; 9
    3a1a:	79 f4       	brne	.+30     	; 0x3a3a <main+0x112>
        if(rq->wValue.bytes[0] == 2){
    3a1c:	12 96       	adiw	r26, 0x02	; 2
    3a1e:	8c 91       	ld	r24, X
    3a20:	12 97       	sbiw	r26, 0x02	; 2
    3a22:	82 30       	cpi	r24, 0x02	; 2
    3a24:	31 f4       	brne	.+12     	; 0x3a32 <main+0x10a>
            offset = 0;
    3a26:	10 92 0d 01 	sts	0x010D, r1
            replyLen = usbDriverSetup(rq);
        }
#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
        if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
            /* do some conditioning on replyLen, but on IN transfers only */
            if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
    3a2a:	27 fd       	sbrc	r18, 7
    3a2c:	80 c0       	rjmp	.+256    	; 0x3b2e <main+0x206>
    3a2e:	9f ef       	ldi	r25, 0xFF	; 255
    3a30:	80 c0       	rjmp	.+256    	; 0x3b32 <main+0x20a>
            return USB_NO_MSG;
        }
#if BOOTLOADER_CAN_EXIT
        else{
            exitMainloop = 1;
    3a32:	e1 e0       	ldi	r30, 0x01	; 1
    3a34:	e0 93 0e 01 	sts	0x010E, r30
    3a38:	4a c1       	rjmp	.+660    	; 0x3cce <main+0x3a6>
        }
#endif
    }else if(rq->bRequest == USBRQ_HID_GET_REPORT){
    3a3a:	91 30       	cpi	r25, 0x01	; 1
    3a3c:	09 f0       	breq	.+2      	; 0x3a40 <main+0x118>
    3a3e:	47 c1       	rjmp	.+654    	; 0x3cce <main+0x3a6>
        usbMsgPtr = replyBuffer;
    3a40:	d0 92 20 01 	sts	0x0120, r13
    3a44:	c0 92 1f 01 	sts	0x011F, r12
    3a48:	27 e0       	ldi	r18, 0x07	; 7
    3a4a:	42 c1       	rjmp	.+644    	; 0x3cd0 <main+0x3a8>
 * standard requests instead of class and custom requests.
 */
static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
{
uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffer */
uchar   value = rq->wValue.bytes[0];
    3a4c:	12 96       	adiw	r26, 0x02	; 2
    3a4e:	2c 91       	ld	r18, X
    3a50:	12 97       	sbiw	r26, 0x02	; 2
#if USB_CFG_IMPLEMENT_HALT
uchar   index = rq->wIndex.bytes[0];
#endif

    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
    3a52:	10 92 1a 01 	sts	0x011A, r1
    SWITCH_START(rq->bRequest)
    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
    3a56:	99 23       	and	r25, r25
    3a58:	31 f4       	brne	.+12     	; 0x3a66 <main+0x13e>
            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
#if USB_CFG_IMPLEMENT_HALT
        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
            dataPtr[0] = usbTxLen1 == USBPID_STALL;
#endif
        dataPtr[1] = 0;
    3a5a:	10 92 1b 01 	sts	0x011B, r1
    3a5e:	8a e1       	ldi	r24, 0x1A	; 26
    3a60:	91 e0       	ldi	r25, 0x01	; 1
    3a62:	22 e0       	ldi	r18, 0x02	; 2
    3a64:	5f c0       	rjmp	.+190    	; 0x3b24 <main+0x1fc>
        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
            usbResetDataToggling();
        }
#endif
    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
    3a66:	95 30       	cpi	r25, 0x05	; 5
    3a68:	19 f4       	brne	.+6      	; 0x3a70 <main+0x148>
        usbNewDeviceAddr = value;
    3a6a:	20 93 22 01 	sts	0x0122, r18
    3a6e:	57 c0       	rjmp	.+174    	; 0x3b1e <main+0x1f6>
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
    3a70:	96 30       	cpi	r25, 0x06	; 6
    3a72:	09 f0       	breq	.+2      	; 0x3a76 <main+0x14e>
    3a74:	44 c0       	rjmp	.+136    	; 0x3afe <main+0x1d6>
static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
{
usbMsgLen_t len = 0;
uchar       flags = USB_FLG_MSGPTR_IS_ROM;

    SWITCH_START(rq->wValue.bytes[1])
    3a76:	13 96       	adiw	r26, 0x03	; 3
    3a78:	8c 91       	ld	r24, X
    3a7a:	13 97       	sbiw	r26, 0x03	; 3
    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
    3a7c:	81 30       	cpi	r24, 0x01	; 1
    3a7e:	31 f4       	brne	.+12     	; 0x3a8c <main+0x164>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
    3a80:	70 92 20 01 	sts	0x0120, r7
    3a84:	60 92 1f 01 	sts	0x011F, r6
    3a88:	22 e1       	ldi	r18, 0x12	; 18
    3a8a:	35 c0       	rjmp	.+106    	; 0x3af6 <main+0x1ce>
    SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
    3a8c:	82 30       	cpi	r24, 0x02	; 2
    3a8e:	31 f4       	brne	.+12     	; 0x3a9c <main+0x174>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
    3a90:	90 92 20 01 	sts	0x0120, r9
    3a94:	80 92 1f 01 	sts	0x011F, r8
    3a98:	22 e2       	ldi	r18, 0x22	; 34
    3a9a:	2d c0       	rjmp	.+90     	; 0x3af6 <main+0x1ce>
    SWITCH_CASE(USBDESCR_STRING)    /* 3 */
    3a9c:	83 30       	cpi	r24, 0x03	; 3
    3a9e:	c1 f4       	brne	.+48     	; 0x3ad0 <main+0x1a8>
        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
            flags = 0;
        len = usbFunctionDescriptor(rq);
#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
        SWITCH_START(rq->wValue.bytes[0])
        SWITCH_CASE(0)
    3aa0:	22 23       	and	r18, r18
    3aa2:	31 f4       	brne	.+12     	; 0x3ab0 <main+0x188>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
    3aa4:	b0 92 20 01 	sts	0x0120, r11
    3aa8:	a0 92 1f 01 	sts	0x011F, r10
    3aac:	24 e0       	ldi	r18, 0x04	; 4
    3aae:	23 c0       	rjmp	.+70     	; 0x3af6 <main+0x1ce>
        SWITCH_CASE(1)
    3ab0:	21 30       	cpi	r18, 0x01	; 1
    3ab2:	31 f4       	brne	.+12     	; 0x3ac0 <main+0x198>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
    3ab4:	30 92 20 01 	sts	0x0120, r3
    3ab8:	20 92 1f 01 	sts	0x011F, r2
    3abc:	2a e0       	ldi	r18, 0x0A	; 10
    3abe:	1b c0       	rjmp	.+54     	; 0x3af6 <main+0x1ce>
        SWITCH_CASE(2)
    3ac0:	22 30       	cpi	r18, 0x02	; 2
    3ac2:	c1 f4       	brne	.+48     	; 0x3af4 <main+0x1cc>
            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
    3ac4:	50 92 20 01 	sts	0x0120, r5
    3ac8:	40 92 1f 01 	sts	0x011F, r4
    3acc:	2e e1       	ldi	r18, 0x1E	; 30
    3ace:	13 c0       	rjmp	.+38     	; 0x3af6 <main+0x1ce>
                len = usbFunctionDescriptor(rq);
            }
        SWITCH_END
#endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
#if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
    SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
    3ad0:	81 32       	cpi	r24, 0x21	; 33
    3ad2:	31 f4       	brne	.+12     	; 0x3ae0 <main+0x1b8>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
    3ad4:	d0 93 20 01 	sts	0x0120, r29
    3ad8:	c0 93 1f 01 	sts	0x011F, r28
    3adc:	29 e0       	ldi	r18, 0x09	; 9
    3ade:	0b c0       	rjmp	.+22     	; 0x3af6 <main+0x1ce>
    SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
    3ae0:	82 32       	cpi	r24, 0x22	; 34
    3ae2:	41 f4       	brne	.+16     	; 0x3af4 <main+0x1cc>
        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
    3ae4:	88 ec       	ldi	r24, 0xC8	; 200
    3ae6:	98 e3       	ldi	r25, 0x38	; 56
    3ae8:	90 93 20 01 	sts	0x0120, r25
    3aec:	80 93 1f 01 	sts	0x011F, r24
    3af0:	21 e2       	ldi	r18, 0x21	; 33
    3af2:	01 c0       	rjmp	.+2      	; 0x3af6 <main+0x1ce>
    3af4:	20 e0       	ldi	r18, 0x00	; 0
    SWITCH_DEFAULT
        if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
            len = usbFunctionDescriptor(rq);
        }
    SWITCH_END
    usbMsgFlags = flags;
    3af6:	90 e4       	ldi	r25, 0x40	; 64
    3af8:	90 93 0a 01 	sts	0x010A, r25
    3afc:	e9 c0       	rjmp	.+466    	; 0x3cd0 <main+0x3a8>
        usbNewDeviceAddr = value;
        USB_SET_ADDRESS_HOOK();
    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
        len = usbDriverDescriptor(rq);
        goto skipMsgPtrAssignment;
    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
    3afe:	98 30       	cpi	r25, 0x08	; 8
    3b00:	19 f4       	brne	.+6      	; 0x3b08 <main+0x1e0>
    3b02:	84 e2       	ldi	r24, 0x24	; 36
    3b04:	91 e0       	ldi	r25, 0x01	; 1
    3b06:	09 c0       	rjmp	.+18     	; 0x3b1a <main+0x1f2>
        dataPtr = &usbConfiguration;  /* send current configuration value */
        len = 1;
    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
    3b08:	99 30       	cpi	r25, 0x09	; 9
    3b0a:	19 f4       	brne	.+6      	; 0x3b12 <main+0x1ea>
        usbConfiguration = value;
    3b0c:	20 93 24 01 	sts	0x0124, r18
    3b10:	06 c0       	rjmp	.+12     	; 0x3b1e <main+0x1f6>
        usbResetStall();
    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
    3b12:	9a 30       	cpi	r25, 0x0A	; 10
    3b14:	21 f4       	brne	.+8      	; 0x3b1e <main+0x1f6>
    3b16:	8a e1       	ldi	r24, 0x1A	; 26
    3b18:	91 e0       	ldi	r25, 0x01	; 1
    3b1a:	21 e0       	ldi	r18, 0x01	; 1
    3b1c:	03 c0       	rjmp	.+6      	; 0x3b24 <main+0x1fc>
    3b1e:	8a e1       	ldi	r24, 0x1A	; 26
    3b20:	91 e0       	ldi	r25, 0x01	; 1
    3b22:	20 e0       	ldi	r18, 0x00	; 0
        usbResetStall();
#endif
    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
        /* Should we add an optional hook here? */
    SWITCH_END
    usbMsgPtr = dataPtr;
    3b24:	90 93 20 01 	sts	0x0120, r25
    3b28:	80 93 1f 01 	sts	0x011F, r24
    3b2c:	d1 c0       	rjmp	.+418    	; 0x3cd0 <main+0x3a8>
#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
        if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
            /* do some conditioning on replyLen, but on IN transfers only */
            if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
                if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
                    replyLen = rq->wLength.bytes[0];
    3b2e:	16 96       	adiw	r26, 0x06	; 6
    3b30:	9c 91       	ld	r25, X
                }else{
                    replyLen = rq->wLength.word;
                }
            }
            usbMsgFlags = USB_FLG_USE_USER_RW;
    3b32:	80 e8       	ldi	r24, 0x80	; 128
    3b34:	80 93 0a 01 	sts	0x010A, r24
    3b38:	05 c0       	rjmp	.+10     	; 0x3b44 <main+0x21c>
        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */
#endif
        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */
    3b3a:	16 96       	adiw	r26, 0x06	; 6
    3b3c:	9c 91       	ld	r25, X
    3b3e:	92 17       	cp	r25, r18
    3b40:	08 f0       	brcs	.+2      	; 0x3b44 <main+0x21c>
    3b42:	92 2f       	mov	r25, r18
                replyLen = rq->wLength.bytes[0];
        }else{
            if(replyLen > rq->wLength.word)     /* limit length to max */
                replyLen = rq->wLength.word;
        }
        usbMsgLen = replyLen;
    3b44:	90 93 01 01 	sts	0x0101, r25
    3b48:	4d c0       	rjmp	.+154    	; 0x3be4 <main+0x2bc>
    }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
#if USB_CFG_IMPLEMENT_FN_WRITE
        if(usbMsgFlags & USB_FLG_USE_USER_RW){
    3b4a:	80 91 0a 01 	lds	r24, 0x010A
    3b4e:	87 ff       	sbrs	r24, 7
    3b50:	49 c0       	rjmp	.+146    	; 0x3be4 <main+0x2bc>
    uint    s[sizeof(addr_t)/2];
    uchar   c[sizeof(addr_t)];
}       address;
uchar   isLast;

    address.l = currentAddress;
    3b52:	60 91 0b 01 	lds	r22, 0x010B
    3b56:	70 91 0c 01 	lds	r23, 0x010C
    if(offset == 0){
    3b5a:	80 91 0d 01 	lds	r24, 0x010D
    3b5e:	88 23       	and	r24, r24
    3b60:	49 f4       	brne	.+18     	; 0x3b74 <main+0x24c>
        //DBG1(0x30, data, 3);
        address.c[0] = data[1];
    3b62:	11 96       	adiw	r26, 0x01	; 1
    3b64:	6c 91       	ld	r22, X
    3b66:	11 97       	sbiw	r26, 0x01	; 1
        address.c[1] = data[2];
    3b68:	12 96       	adiw	r26, 0x02	; 2
    3b6a:	7c 91       	ld	r23, X
    3b6c:	12 97       	sbiw	r26, 0x02	; 2
#if (FLASHEND) > 0xffff /* we need long addressing */
        address.c[2] = data[3];
        address.c[3] = 0;
#endif
        data += 4;
    3b6e:	14 96       	adiw	r26, 0x04	; 4
        len -= 4;
    3b70:	29 2f       	mov	r18, r25
    3b72:	27 50       	subi	r18, 0x07	; 7
    }
    //DBG1(0x31, (void *)&currentAddress, 4);
    offset += len;
    3b74:	32 2f       	mov	r19, r18
    3b76:	38 0f       	add	r19, r24
    3b78:	30 93 0d 01 	sts	0x010D, r19
#else
        uchar pageAddr;
#endif
        //DBG1(0x32, 0, 0);
        pageAddr = address.s[0] & (SPM_PAGESIZE - 1);
        if(pageAddr == 0){              /* if page start: erase */
    3b7c:	86 2f       	mov	r24, r22
    3b7e:	8f 77       	andi	r24, 0x7F	; 127
    3b80:	51 f4       	brne	.+20     	; 0x3b96 <main+0x26e>
            //DBG1(0x33, 0, 0);
#ifndef TEST_MODE
            cli();
    3b82:	f8 94       	cli
            boot_page_erase(address.l); /* erase page */
    3b84:	83 e0       	ldi	r24, 0x03	; 3
    3b86:	fb 01       	movw	r30, r22
    3b88:	80 93 57 00 	sts	0x0057, r24
    3b8c:	e8 95       	spm
            sei();
    3b8e:	78 94       	sei
            boot_spm_busy_wait();       /* wait until page is erased */
    3b90:	07 b6       	in	r0, 0x37	; 55
    3b92:	00 fc       	sbrc	r0, 0
    3b94:	fd cf       	rjmp	.-6      	; 0x3b90 <main+0x268>
#endif
        }
        cli();
    3b96:	f8 94       	cli
        boot_page_fill(address.l, *(short *)data);
    3b98:	ab 01       	movw	r20, r22
    3b9a:	8d 91       	ld	r24, X+
    3b9c:	9c 91       	ld	r25, X
    3b9e:	11 97       	sbiw	r26, 0x01	; 1
    3ba0:	fb 01       	movw	r30, r22
    3ba2:	0c 01       	movw	r0, r24
    3ba4:	e0 92 57 00 	sts	0x0057, r14
    3ba8:	e8 95       	spm
    3baa:	11 24       	eor	r1, r1
        sei();
    3bac:	78 94       	sei
        prevAddr = address.l;
        address.l += 2;
    3bae:	6e 5f       	subi	r22, 0xFE	; 254
    3bb0:	7f 4f       	sbci	r23, 0xFF	; 255
        data += 2;
        /* write page when we cross page boundary */
        pageAddr = address.s[0] & (SPM_PAGESIZE - 1);
        if(pageAddr == 0){
    3bb2:	86 2f       	mov	r24, r22
    3bb4:	8f 77       	andi	r24, 0x7F	; 127
    3bb6:	51 f4       	brne	.+20     	; 0x3bcc <main+0x2a4>
            //DBG1(0x34, 0, 0);
#ifndef TEST_MODE
            cli();
    3bb8:	f8 94       	cli
            boot_page_write(prevAddr);
    3bba:	85 e0       	ldi	r24, 0x05	; 5
    3bbc:	fa 01       	movw	r30, r20
    3bbe:	80 93 57 00 	sts	0x0057, r24
    3bc2:	e8 95       	spm
            sei();
    3bc4:	78 94       	sei
            boot_spm_busy_wait();
    3bc6:	07 b6       	in	r0, 0x37	; 55
    3bc8:	00 fc       	sbrc	r0, 0
    3bca:	fd cf       	rjmp	.-6      	; 0x3bc6 <main+0x29e>
#endif
        }
        len -= 2;
    3bcc:	22 50       	subi	r18, 0x02	; 2
    }while(len);
    3bce:	11 f0       	breq	.+4      	; 0x3bd4 <main+0x2ac>
        cli();
        boot_page_fill(address.l, *(short *)data);
        sei();
        prevAddr = address.l;
        address.l += 2;
        data += 2;
    3bd0:	12 96       	adiw	r26, 0x02	; 2
    3bd2:	d4 cf       	rjmp	.-88     	; 0x3b7c <main+0x254>
            boot_spm_busy_wait();
#endif
        }
        len -= 2;
    }while(len);
    currentAddress = address.l;
    3bd4:	70 93 0c 01 	sts	0x010C, r23
    3bd8:	60 93 0b 01 	sts	0x010B, r22
            uchar rval = usbFunctionWrite(data, len);
            if(rval == 0xff){   /* an error occurred */
                usbTxLen = USBPID_STALL;
            }else if(rval != 0){    /* This was the final package */
    3bdc:	37 ff       	sbrs	r19, 7
    3bde:	02 c0       	rjmp	.+4      	; 0x3be4 <main+0x2bc>
                usbMsgLen = 0;  /* answer with a zero-sized data packet */
    3be0:	10 92 01 01 	sts	0x0101, r1
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
#if USB_CFG_HAVE_FLOWCONTROL
        if(usbRxLen > 0)    /* only mark as available if not inactivated */
            usbRxLen = 0;
#else
        usbRxLen = 0;       /* mark rx buffer as available */
    3be4:	10 92 21 01 	sts	0x0121, r1
#endif
    }
    if(usbTxLen & 0x10){    /* transmit system idle */
    3be8:	80 91 00 01 	lds	r24, 0x0100
    3bec:	84 ff       	sbrs	r24, 4
    3bee:	4a c0       	rjmp	.+148    	; 0x3c84 <main+0x35c>
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
    3bf0:	80 91 01 01 	lds	r24, 0x0101
    3bf4:	8f 3f       	cpi	r24, 0xFF	; 255
    3bf6:	09 f4       	brne	.+2      	; 0x3bfa <main+0x2d2>
    3bf8:	45 c0       	rjmp	.+138    	; 0x3c84 <main+0x35c>
    3bfa:	18 2f       	mov	r17, r24
    3bfc:	89 30       	cpi	r24, 0x09	; 9
    3bfe:	08 f0       	brcs	.+2      	; 0x3c02 <main+0x2da>
    3c00:	18 e0       	ldi	r17, 0x08	; 8
uchar       len;

    wantLen = usbMsgLen;
    if(wantLen > 8)
        wantLen = 8;
    usbMsgLen -= wantLen;
    3c02:	81 1b       	sub	r24, r17
    3c04:	80 93 01 01 	sts	0x0101, r24
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    3c08:	80 91 11 01 	lds	r24, 0x0111
    3c0c:	98 e8       	ldi	r25, 0x88	; 136
    3c0e:	89 27       	eor	r24, r25
    3c10:	80 93 11 01 	sts	0x0111, r24
/* This function is similar to usbFunctionRead(), but it's also called for
 * data handled automatically by the driver (e.g. descriptor reads).
 */
static uchar usbDeviceRead(uchar *data, uchar len)
{
    if(len > 0){    /* don't bother app with 0 sized reads */
    3c14:	11 23       	and	r17, r17
    3c16:	41 f1       	breq	.+80     	; 0x3c68 <main+0x340>
        if(usbMsgFlags & USB_FLG_USE_USER_RW){
            len = usbFunctionRead(data, len);
        }else
#endif
        {
            uchar i = len, *r = usbMsgPtr;
    3c18:	20 91 1f 01 	lds	r18, 0x011F
    3c1c:	30 91 20 01 	lds	r19, 0x0120
            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
    3c20:	80 91 0a 01 	lds	r24, 0x010A
    3c24:	86 ff       	sbrs	r24, 6
    3c26:	0d c0       	rjmp	.+26     	; 0x3c42 <main+0x31a>
    3c28:	a2 e1       	ldi	r26, 0x12	; 18
    3c2a:	b1 e0       	ldi	r27, 0x01	; 1
    3c2c:	80 e0       	ldi	r24, 0x00	; 0
    3c2e:	90 e0       	ldi	r25, 0x00	; 0
                do{
                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */
    3c30:	f9 01       	movw	r30, r18
    3c32:	e8 0f       	add	r30, r24
    3c34:	f9 1f       	adc	r31, r25
    3c36:	e4 91       	lpm	r30, Z+
                    *data++ = c;
    3c38:	ed 93       	st	X+, r30
    3c3a:	01 96       	adiw	r24, 0x01	; 1
                    r++;
                }while(--i);
    3c3c:	18 17       	cp	r17, r24
    3c3e:	c1 f7       	brne	.-16     	; 0x3c30 <main+0x308>
    3c40:	08 c0       	rjmp	.+16     	; 0x3c52 <main+0x32a>
    3c42:	d9 01       	movw	r26, r18
    3c44:	91 2f       	mov	r25, r17
    3c46:	e2 e1       	ldi	r30, 0x12	; 18
    3c48:	f1 e0       	ldi	r31, 0x01	; 1
            }else{  /* RAM data */
                do{
                    *data++ = *r++;
    3c4a:	8d 91       	ld	r24, X+
    3c4c:	81 93       	st	Z+, r24
                }while(--i);
    3c4e:	91 50       	subi	r25, 0x01	; 1
    3c50:	e1 f7       	brne	.-8      	; 0x3c4a <main+0x322>
    3c52:	11 50       	subi	r17, 0x01	; 1
    3c54:	81 2f       	mov	r24, r17
    3c56:	90 e0       	ldi	r25, 0x00	; 0
    3c58:	1f 5f       	subi	r17, 0xFF	; 255
    3c5a:	01 96       	adiw	r24, 0x01	; 1
    3c5c:	82 0f       	add	r24, r18
    3c5e:	93 1f       	adc	r25, r19
            }
            usbMsgPtr = r;
    3c60:	90 93 20 01 	sts	0x0120, r25
    3c64:	80 93 1f 01 	sts	0x011F, r24
        wantLen = 8;
    usbMsgLen -= wantLen;
    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
    len = usbDeviceRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
        usbCrc16Append(&usbTxBuf[1], len);
    3c68:	82 e1       	ldi	r24, 0x12	; 18
    3c6a:	91 e0       	ldi	r25, 0x01	; 1
    3c6c:	61 2f       	mov	r22, r17
    3c6e:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <usbCrc16Append>
        len += 4;           /* length including sync byte */
    3c72:	61 2f       	mov	r22, r17
    3c74:	6c 5f       	subi	r22, 0xFC	; 252
        if(len < 12)        /* a partial package identifies end of message */
    3c76:	6c 30       	cpi	r22, 0x0C	; 12
    3c78:	19 f0       	breq	.+6      	; 0x3c80 <main+0x358>
            usbMsgLen = USB_NO_MSG;
    3c7a:	8f ef       	ldi	r24, 0xFF	; 255
    3c7c:	80 93 01 01 	sts	0x0101, r24
    }else{
        len = USBPID_STALL;   /* stall the endpoint */
        usbMsgLen = USB_NO_MSG;
    }
    usbTxLen = len;
    3c80:	60 93 00 01 	sts	0x0100, r22
    3c84:	94 e1       	ldi	r25, 0x14	; 20
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 20; i > 0; i--){
        uchar usbLineStatus = USBIN & USBMASK;
    3c86:	89 b1       	in	r24, 0x09	; 9
        if(usbLineStatus != 0)  /* SE0 has ended */
    3c88:	86 70       	andi	r24, 0x06	; 6
    3c8a:	31 f4       	brne	.+12     	; 0x3c98 <main+0x370>
    if(usbTxLen & 0x10){    /* transmit system idle */
        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 20; i > 0; i--){
    3c8c:	91 50       	subi	r25, 0x01	; 1
    3c8e:	d9 f7       	brne	.-10     	; 0x3c86 <main+0x35e>
        uchar usbLineStatus = USBIN & USBMASK;
        if(usbLineStatus != 0)  /* SE0 has ended */
            goto isNotReset;
    }
    /* RESET condition, called multiple times during reset */
    usbNewDeviceAddr = 0;
    3c90:	10 92 22 01 	sts	0x0122, r1
    usbDeviceAddr = 0;
    3c94:	10 92 1c 01 	sts	0x011C, r1
        initForUsbConnectivity();
        do{ /* main event loop */
            //wdt_reset();
            usbPoll();
#if BOOTLOADER_CAN_EXIT
            if(exitMainloop){
    3c98:	80 91 0e 01 	lds	r24, 0x010E
    3c9c:	88 23       	and	r24, r24
    3c9e:	09 f4       	brne	.+2      	; 0x3ca2 <main+0x37a>
    3ca0:	95 ce       	rjmp	.-726    	; 0x39cc <main+0xa4>
#if F_CPU == 12800000
                break;  /* memory is tight at 12.8 MHz, save exit delay below */
#endif
                if(--i == 0){
    3ca2:	fa 94       	dec	r15
    3ca4:	09 f0       	breq	.+2      	; 0x3ca8 <main+0x380>
    3ca6:	92 ce       	rjmp	.-732    	; 0x39cc <main+0xa4>
                    if(--j == 0)
    3ca8:	01 50       	subi	r16, 0x01	; 1
    3caa:	09 f0       	breq	.+2      	; 0x3cae <main+0x386>
    3cac:	8f ce       	rjmp	.-738    	; 0x39cc <main+0xa4>
static void (*nullVector)(void) __attribute__((__noreturn__));

static void leaveBootloader()
{
    //DBG1(0x01, 0, 0);
    cli();
    3cae:	f8 94       	cli
    boot_rww_enable();
    3cb0:	81 e1       	ldi	r24, 0x11	; 17
    3cb2:	80 93 57 00 	sts	0x0057, r24
    3cb6:	e8 95       	spm
    USB_INTR_ENABLE = 0;
    3cb8:	1d ba       	out	0x1d, r1	; 29
    USB_INTR_CFG = 0;       /* also reset config bits */
    3cba:	10 92 69 00 	sts	0x0069, r1
#if F_CPU == 12800000
    TCCR0 = 0;              /* default value */
#endif
    GICR = (1 << IVCE);     /* enable change of interrupt vectors */
    3cbe:	81 e0       	ldi	r24, 0x01	; 1
    3cc0:	85 bf       	out	0x35, r24	; 53
    GICR = (0 << IVSEL);    /* move interrupts to application flash section */
    3cc2:	15 be       	out	0x35, r1	; 53
/* We must go through a global function pointer variable instead of writing
 *  ((void (*)(void))0)();
 * because the compiler optimizes a constant 0 to "rcall 0" which is not
 * handled correctly by the assembler.
 */
    nullVector();
    3cc4:	e0 91 0f 01 	lds	r30, 0x010F
    3cc8:	f0 91 10 01 	lds	r31, 0x0110
    3ccc:	09 95       	icall
    3cce:	20 e0       	ldi	r18, 0x00	; 0
            }
            usbMsgFlags = USB_FLG_USE_USER_RW;
        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */
#endif
        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */
    3cd0:	17 96       	adiw	r26, 0x07	; 7
    3cd2:	8c 91       	ld	r24, X
    3cd4:	17 97       	sbiw	r26, 0x07	; 7
    3cd6:	88 23       	and	r24, r24
    3cd8:	09 f4       	brne	.+2      	; 0x3cdc <main+0x3b4>
    3cda:	2f cf       	rjmp	.-418    	; 0x3b3a <main+0x212>
    3cdc:	32 cf       	rjmp	.-412    	; 0x3b42 <main+0x21a>

00003cde <usbCrc16>:
    3cde:	a8 2f       	mov	r26, r24
    3ce0:	b9 2f       	mov	r27, r25
    3ce2:	80 e0       	ldi	r24, 0x00	; 0
    3ce4:	90 e0       	ldi	r25, 0x00	; 0
    3ce6:	41 e0       	ldi	r20, 0x01	; 1
    3ce8:	50 ea       	ldi	r21, 0xA0	; 160
    3cea:	60 95       	com	r22

00003cec <crcByteLoop>:
    3cec:	6f 5f       	subi	r22, 0xFF	; 255
    3cee:	58 f4       	brcc	.+22     	; 0x3d06 <crcReady>
    3cf0:	2d 91       	ld	r18, X+
    3cf2:	38 ef       	ldi	r19, 0xF8	; 248
    3cf4:	82 27       	eor	r24, r18

00003cf6 <crcBitLoop>:
    3cf6:	97 95       	ror	r25
    3cf8:	87 95       	ror	r24
    3cfa:	10 f0       	brcs	.+4      	; 0x3d00 <crcNoXor>
    3cfc:	84 27       	eor	r24, r20
    3cfe:	95 27       	eor	r25, r21

00003d00 <crcNoXor>:
    3d00:	3f 5f       	subi	r19, 0xFF	; 255
    3d02:	c8 f3       	brcs	.-14     	; 0x3cf6 <crcBitLoop>
    3d04:	f3 cf       	rjmp	.-26     	; 0x3cec <crcByteLoop>

00003d06 <crcReady>:
    3d06:	08 95       	ret

00003d08 <usbCrc16Append>:
    3d08:	ea df       	rcall	.-44     	; 0x3cde <usbCrc16>
    3d0a:	8d 93       	st	X+, r24
    3d0c:	9d 93       	st	X+, r25
    3d0e:	08 95       	ret

00003d10 <__vector_1>:
    3d10:	cf 93       	push	r28
    3d12:	cf b7       	in	r28, 0x3f	; 63
    3d14:	cf 93       	push	r28

00003d16 <waitForJ>:
    3d16:	c3 95       	inc	r28
    3d18:	49 9b       	sbis	0x09, 1	; 9
    3d1a:	e9 f7       	brne	.-6      	; 0x3d16 <waitForJ>

00003d1c <waitForK>:
    3d1c:	49 9b       	sbis	0x09, 1	; 9
    3d1e:	0b c0       	rjmp	.+22     	; 0x3d36 <foundK>
    3d20:	49 9b       	sbis	0x09, 1	; 9
    3d22:	09 c0       	rjmp	.+18     	; 0x3d36 <foundK>
    3d24:	49 9b       	sbis	0x09, 1	; 9
    3d26:	07 c0       	rjmp	.+14     	; 0x3d36 <foundK>
    3d28:	49 9b       	sbis	0x09, 1	; 9
    3d2a:	05 c0       	rjmp	.+10     	; 0x3d36 <foundK>
    3d2c:	49 9b       	sbis	0x09, 1	; 9
    3d2e:	03 c0       	rjmp	.+6      	; 0x3d36 <foundK>
    3d30:	49 9b       	sbis	0x09, 1	; 9
    3d32:	01 c0       	rjmp	.+2      	; 0x3d36 <foundK>
    3d34:	c2 c0       	rjmp	.+388    	; 0x3eba <sofError>

00003d36 <foundK>:
    3d36:	c0 91 1e 01 	lds	r28, 0x011E
    3d3a:	df 93       	push	r29
    3d3c:	dd 27       	eor	r29, r29
    3d3e:	cb 5d       	subi	r28, 0xDB	; 219
    3d40:	de 4f       	sbci	r29, 0xFE	; 254
    3d42:	2f 93       	push	r18
    3d44:	2f ef       	ldi	r18, 0xFF	; 255
    3d46:	49 9b       	sbis	0x09, 1	; 9
    3d48:	03 c0       	rjmp	.+6      	; 0x3d50 <haveTwoBitsK>
    3d4a:	2f 91       	pop	r18
    3d4c:	df 91       	pop	r29
    3d4e:	e6 cf       	rjmp	.-52     	; 0x3d1c <waitForK>

00003d50 <haveTwoBitsK>:
    3d50:	0f 93       	push	r16
    3d52:	1f 93       	push	r17
    3d54:	4f 93       	push	r20
    3d56:	6f 93       	push	r22
    3d58:	09 b1       	in	r16, 0x09	; 9
    3d5a:	01 fb       	bst	r16, 1
    3d5c:	20 f9       	bld	r18, 0
    3d5e:	3f 93       	push	r19
    3d60:	3b e0       	ldi	r19, 0x0B	; 11
    3d62:	5f 93       	push	r21
    3d64:	1e c0       	rjmp	.+60     	; 0x3da2 <rxLoop>

00003d66 <unstuff0>:
    3d66:	4e 7f       	andi	r20, 0xFE	; 254
    3d68:	01 2f       	mov	r16, r17
    3d6a:	19 b1       	in	r17, 0x09	; 9
    3d6c:	16 70       	andi	r17, 0x06	; 6
    3d6e:	e1 f0       	breq	.+56     	; 0x3da8 <se0Hop>
    3d70:	21 60       	ori	r18, 0x01	; 1
    3d72:	00 00       	nop
    3d74:	1d c0       	rjmp	.+58     	; 0x3db0 <didUnstuff0>

00003d76 <unstuff1>:
    3d76:	10 2f       	mov	r17, r16
    3d78:	4d 7f       	andi	r20, 0xFD	; 253
    3d7a:	22 60       	ori	r18, 0x02	; 2
    3d7c:	00 00       	nop
    3d7e:	09 b1       	in	r16, 0x09	; 9
    3d80:	06 70       	andi	r16, 0x06	; 6
    3d82:	91 f0       	breq	.+36     	; 0x3da8 <se0Hop>
    3d84:	1d c0       	rjmp	.+58     	; 0x3dc0 <didUnstuff1>

00003d86 <unstuff2>:
    3d86:	4b 7f       	andi	r20, 0xFB	; 251
    3d88:	24 60       	ori	r18, 0x04	; 4
    3d8a:	01 2f       	mov	r16, r17
    3d8c:	00 00       	nop
    3d8e:	19 b1       	in	r17, 0x09	; 9
    3d90:	16 70       	andi	r17, 0x06	; 6
    3d92:	51 f0       	breq	.+20     	; 0x3da8 <se0Hop>
    3d94:	1e c0       	rjmp	.+60     	; 0x3dd2 <didUnstuff2>

00003d96 <unstuff3>:
    3d96:	19 b1       	in	r17, 0x09	; 9
    3d98:	16 70       	andi	r17, 0x06	; 6
    3d9a:	31 f0       	breq	.+12     	; 0x3da8 <se0Hop>
    3d9c:	47 7f       	andi	r20, 0xF7	; 247
    3d9e:	28 60       	ori	r18, 0x08	; 8
    3da0:	1b c0       	rjmp	.+54     	; 0x3dd8 <didUnstuff3>

00003da2 <rxLoop>:
    3da2:	19 b1       	in	r17, 0x09	; 9
    3da4:	16 70       	andi	r17, 0x06	; 6
    3da6:	09 f4       	brne	.+2      	; 0x3daa <SkipSe0Hop>

00003da8 <se0Hop>:
    3da8:	62 c0       	rjmp	.+196    	; 0x3e6e <se0>

00003daa <SkipSe0Hop>:
    3daa:	4f ef       	ldi	r20, 0xFF	; 255
    3dac:	29 7f       	andi	r18, 0xF9	; 249
    3dae:	d9 f2       	breq	.-74     	; 0x3d66 <unstuff0>

00003db0 <didUnstuff0>:
    3db0:	01 27       	eor	r16, r17
    3db2:	01 fb       	bst	r16, 1
    3db4:	21 f9       	bld	r18, 1
    3db6:	09 b1       	in	r16, 0x09	; 9
    3db8:	06 70       	andi	r16, 0x06	; 6
    3dba:	b1 f3       	breq	.-20     	; 0x3da8 <se0Hop>
    3dbc:	23 7f       	andi	r18, 0xF3	; 243
    3dbe:	d9 f2       	breq	.-74     	; 0x3d76 <unstuff1>

00003dc0 <didUnstuff1>:
    3dc0:	10 27       	eor	r17, r16
    3dc2:	11 fb       	bst	r17, 1
    3dc4:	22 f9       	bld	r18, 2
    3dc6:	00 c0       	rjmp	.+0      	; 0x3dc8 <didUnstuff1+0x8>
    3dc8:	19 b1       	in	r17, 0x09	; 9
    3dca:	16 70       	andi	r17, 0x06	; 6
    3dcc:	69 f3       	breq	.-38     	; 0x3da8 <se0Hop>
    3dce:	27 7e       	andi	r18, 0xE7	; 231
    3dd0:	d1 f2       	breq	.-76     	; 0x3d86 <unstuff2>

00003dd2 <didUnstuff2>:
    3dd2:	01 27       	eor	r16, r17
    3dd4:	01 fb       	bst	r16, 1
    3dd6:	23 f9       	bld	r18, 3

00003dd8 <didUnstuff3>:
    3dd8:	2f 7c       	andi	r18, 0xCF	; 207
    3dda:	e9 f2       	breq	.-70     	; 0x3d96 <unstuff3>
    3ddc:	09 b1       	in	r16, 0x09	; 9
    3dde:	06 70       	andi	r16, 0x06	; 6
    3de0:	19 f3       	breq	.-58     	; 0x3da8 <se0Hop>
    3de2:	10 27       	eor	r17, r16
    3de4:	11 fb       	bst	r17, 1
    3de6:	24 f9       	bld	r18, 4

00003de8 <didUnstuff4>:
    3de8:	2f 79       	andi	r18, 0x9F	; 159
    3dea:	29 f1       	breq	.+74     	; 0x3e36 <unstuff4>
    3dec:	00 c0       	rjmp	.+0      	; 0x3dee <didUnstuff4+0x6>
    3dee:	19 b1       	in	r17, 0x09	; 9
    3df0:	16 70       	andi	r17, 0x06	; 6
    3df2:	e9 f1       	breq	.+122    	; 0x3e6e <se0>
    3df4:	01 27       	eor	r16, r17
    3df6:	01 fb       	bst	r16, 1
    3df8:	25 f9       	bld	r18, 5

00003dfa <didUnstuff5>:
    3dfa:	2f 73       	andi	r18, 0x3F	; 63
    3dfc:	11 f1       	breq	.+68     	; 0x3e42 <unstuff5>
    3dfe:	00 c0       	rjmp	.+0      	; 0x3e00 <didUnstuff5+0x6>
    3e00:	09 b1       	in	r16, 0x09	; 9
    3e02:	06 70       	andi	r16, 0x06	; 6
    3e04:	a1 f1       	breq	.+104    	; 0x3e6e <se0>
    3e06:	10 27       	eor	r17, r16
    3e08:	11 fb       	bst	r17, 1
    3e0a:	26 f9       	bld	r18, 6

00003e0c <didUnstuff6>:
    3e0c:	22 30       	cpi	r18, 0x02	; 2
    3e0e:	f8 f0       	brcs	.+62     	; 0x3e4e <unstuff6>
    3e10:	00 c0       	rjmp	.+0      	; 0x3e12 <didUnstuff6+0x6>
    3e12:	19 b1       	in	r17, 0x09	; 9
    3e14:	16 70       	andi	r17, 0x06	; 6
    3e16:	59 f1       	breq	.+86     	; 0x3e6e <se0>
    3e18:	01 27       	eor	r16, r17
    3e1a:	01 fb       	bst	r16, 1
    3e1c:	27 f9       	bld	r18, 7

00003e1e <didUnstuff7>:
    3e1e:	24 30       	cpi	r18, 0x04	; 4
    3e20:	e0 f0       	brcs	.+56     	; 0x3e5a <unstuff7>
    3e22:	42 27       	eor	r20, r18
    3e24:	00 00       	nop
    3e26:	09 b1       	in	r16, 0x09	; 9
    3e28:	49 93       	st	Y+, r20
    3e2a:	10 27       	eor	r17, r16
    3e2c:	11 fb       	bst	r17, 1
    3e2e:	20 f9       	bld	r18, 0
    3e30:	31 50       	subi	r19, 0x01	; 1
    3e32:	c8 f0       	brcs	.+50     	; 0x3e66 <overflow>
    3e34:	b6 cf       	rjmp	.-148    	; 0x3da2 <rxLoop>

00003e36 <unstuff4>:
    3e36:	4f 7e       	andi	r20, 0xEF	; 239
    3e38:	09 b1       	in	r16, 0x09	; 9
    3e3a:	06 70       	andi	r16, 0x06	; 6
    3e3c:	c1 f0       	breq	.+48     	; 0x3e6e <se0>
    3e3e:	20 61       	ori	r18, 0x10	; 16
    3e40:	d3 cf       	rjmp	.-90     	; 0x3de8 <didUnstuff4>

00003e42 <unstuff5>:
    3e42:	20 62       	ori	r18, 0x20	; 32
    3e44:	19 b1       	in	r17, 0x09	; 9
    3e46:	16 70       	andi	r17, 0x06	; 6
    3e48:	91 f0       	breq	.+36     	; 0x3e6e <se0>
    3e4a:	4f 7d       	andi	r20, 0xDF	; 223
    3e4c:	d6 cf       	rjmp	.-84     	; 0x3dfa <didUnstuff5>

00003e4e <unstuff6>:
    3e4e:	4f 7b       	andi	r20, 0xBF	; 191
    3e50:	09 b1       	in	r16, 0x09	; 9
    3e52:	06 70       	andi	r16, 0x06	; 6
    3e54:	61 f0       	breq	.+24     	; 0x3e6e <se0>
    3e56:	20 64       	ori	r18, 0x40	; 64
    3e58:	d9 cf       	rjmp	.-78     	; 0x3e0c <didUnstuff6>

00003e5a <unstuff7>:
    3e5a:	4f 77       	andi	r20, 0x7F	; 127
    3e5c:	19 b1       	in	r17, 0x09	; 9
    3e5e:	16 70       	andi	r17, 0x06	; 6
    3e60:	31 f0       	breq	.+12     	; 0x3e6e <se0>
    3e62:	20 68       	ori	r18, 0x80	; 128
    3e64:	dc cf       	rjmp	.-72     	; 0x3e1e <didUnstuff7>

00003e66 <overflow>:
    3e66:	11 e0       	ldi	r17, 0x01	; 1
    3e68:	1c bb       	out	0x1c, r17	; 28

00003e6a <ignorePacket>:
    3e6a:	00 27       	eor	r16, r16
    3e6c:	19 c0       	rjmp	.+50     	; 0x3ea0 <handleSetupOrOut>

00003e6e <se0>:
    3e6e:	3b 50       	subi	r19, 0x0B	; 11
    3e70:	31 95       	neg	r19
    3e72:	c3 1b       	sub	r28, r19
    3e74:	d0 40       	sbci	r29, 0x00	; 0
    3e76:	11 e0       	ldi	r17, 0x01	; 1
    3e78:	1c bb       	out	0x1c, r17	; 28
    3e7a:	08 81       	ld	r16, Y
    3e7c:	03 3c       	cpi	r16, 0xC3	; 195
    3e7e:	09 f1       	breq	.+66     	; 0x3ec2 <handleData>
    3e80:	0b 34       	cpi	r16, 0x4B	; 75
    3e82:	f9 f0       	breq	.+62     	; 0x3ec2 <handleData>
    3e84:	20 91 1c 01 	lds	r18, 0x011C
    3e88:	19 81       	ldd	r17, Y+1	; 0x01
    3e8a:	11 0f       	add	r17, r17
    3e8c:	12 13       	cpse	r17, r18
    3e8e:	ed cf       	rjmp	.-38     	; 0x3e6a <ignorePacket>
    3e90:	4a 81       	ldd	r20, Y+2	; 0x02
    3e92:	44 1f       	adc	r20, r20
    3e94:	09 36       	cpi	r16, 0x69	; 105
    3e96:	51 f1       	breq	.+84     	; 0x3eec <handleIn>
    3e98:	0d 32       	cpi	r16, 0x2D	; 45
    3e9a:	11 f0       	breq	.+4      	; 0x3ea0 <handleSetupOrOut>
    3e9c:	01 3e       	cpi	r16, 0xE1	; 225
    3e9e:	29 f7       	brne	.-54     	; 0x3e6a <ignorePacket>

00003ea0 <handleSetupOrOut>:
    3ea0:	00 93 23 01 	sts	0x0123, r16

00003ea4 <doReturn>:
    3ea4:	5f 91       	pop	r21
    3ea6:	3f 91       	pop	r19
    3ea8:	6f 91       	pop	r22
    3eaa:	4f 91       	pop	r20
    3eac:	1f 91       	pop	r17
    3eae:	0f 91       	pop	r16
    3eb0:	2f 91       	pop	r18
    3eb2:	df 91       	pop	r29
    3eb4:	cc b3       	in	r28, 0x1c	; 28
    3eb6:	c0 fd       	sbrc	r28, 0
    3eb8:	2e cf       	rjmp	.-420    	; 0x3d16 <waitForJ>

00003eba <sofError>:
    3eba:	cf 91       	pop	r28
    3ebc:	cf bf       	out	0x3f, r28	; 63
    3ebe:	cf 91       	pop	r28
    3ec0:	18 95       	reti

00003ec2 <handleData>:
    3ec2:	20 91 23 01 	lds	r18, 0x0123
    3ec6:	22 23       	and	r18, r18
    3ec8:	69 f3       	breq	.-38     	; 0x3ea4 <doReturn>
    3eca:	10 91 21 01 	lds	r17, 0x0121
    3ece:	11 23       	and	r17, r17
    3ed0:	41 f5       	brne	.+80     	; 0x3f22 <sendNakAndReti>
    3ed2:	34 30       	cpi	r19, 0x04	; 4
    3ed4:	42 f1       	brmi	.+80     	; 0x3f26 <sendAckAndReti>
    3ed6:	30 93 21 01 	sts	0x0121, r19
    3eda:	20 93 1d 01 	sts	0x011D, r18
    3ede:	10 91 1e 01 	lds	r17, 0x011E
    3ee2:	3b e0       	ldi	r19, 0x0B	; 11
    3ee4:	31 1b       	sub	r19, r17
    3ee6:	30 93 1e 01 	sts	0x011E, r19
    3eea:	1d c0       	rjmp	.+58     	; 0x3f26 <sendAckAndReti>

00003eec <handleIn>:
    3eec:	00 91 21 01 	lds	r16, 0x0121
    3ef0:	01 30       	cpi	r16, 0x01	; 1
    3ef2:	bc f4       	brge	.+46     	; 0x3f22 <sendNakAndReti>
    3ef4:	0a e5       	ldi	r16, 0x5A	; 90
    3ef6:	4f 70       	andi	r20, 0x0F	; 15
    3ef8:	a1 f4       	brne	.+40     	; 0x3f22 <sendNakAndReti>
    3efa:	30 91 00 01 	lds	r19, 0x0100
    3efe:	34 fd       	sbrc	r19, 4
    3f00:	13 c0       	rjmp	.+38     	; 0x3f28 <sendCntAndReti>
    3f02:	00 93 00 01 	sts	0x0100, r16
    3f06:	c1 e1       	ldi	r28, 0x11	; 17
    3f08:	d1 e0       	ldi	r29, 0x01	; 1
    3f0a:	12 c0       	rjmp	.+36     	; 0x3f30 <usbSendAndReti>

00003f0c <bitstuffN>:
    3f0c:	05 27       	eor	r16, r21
    3f0e:	11 27       	eor	r17, r17
    3f10:	00 00       	nop
    3f12:	19 c0       	rjmp	.+50     	; 0x3f46 <didStuffN>

00003f14 <bitstuff6>:
    3f14:	05 27       	eor	r16, r21
    3f16:	11 27       	eor	r17, r17
    3f18:	1f c0       	rjmp	.+62     	; 0x3f58 <didStuff6>

00003f1a <bitstuff7>:
    3f1a:	05 27       	eor	r16, r21
    3f1c:	11 27       	eor	r17, r17
    3f1e:	00 00       	nop
    3f20:	24 c0       	rjmp	.+72     	; 0x3f6a <didStuff7>

00003f22 <sendNakAndReti>:
    3f22:	4a e5       	ldi	r20, 0x5A	; 90
    3f24:	02 c0       	rjmp	.+4      	; 0x3f2a <sendX3AndReti>

00003f26 <sendAckAndReti>:
    3f26:	32 ed       	ldi	r19, 0xD2	; 210

00003f28 <sendCntAndReti>:
    3f28:	43 2f       	mov	r20, r19

00003f2a <sendX3AndReti>:
    3f2a:	c4 e1       	ldi	r28, 0x14	; 20
    3f2c:	d0 e0       	ldi	r29, 0x00	; 0
    3f2e:	32 e0       	ldi	r19, 0x02	; 2

00003f30 <usbSendAndReti>:
    3f30:	1a b1       	in	r17, 0x0a	; 10
    3f32:	16 60       	ori	r17, 0x06	; 6
    3f34:	59 9a       	sbi	0x0b, 1	; 11
    3f36:	0b b1       	in	r16, 0x0b	; 11
    3f38:	1a b9       	out	0x0a, r17	; 10
    3f3a:	56 e0       	ldi	r21, 0x06	; 6
    3f3c:	20 e8       	ldi	r18, 0x80	; 128
    3f3e:	66 e0       	ldi	r22, 0x06	; 6

00003f40 <txBitLoop>:
    3f40:	20 ff       	sbrs	r18, 0
    3f42:	05 27       	eor	r16, r21
    3f44:	27 95       	ror	r18

00003f46 <didStuffN>:
    3f46:	0b b9       	out	0x0b, r16	; 11
    3f48:	17 95       	ror	r17
    3f4a:	1c 3f       	cpi	r17, 0xFC	; 252
    3f4c:	f8 f6       	brcc	.-66     	; 0x3f0c <bitstuffN>
    3f4e:	6a 95       	dec	r22
    3f50:	b9 f7       	brne	.-18     	; 0x3f40 <txBitLoop>
    3f52:	20 ff       	sbrs	r18, 0
    3f54:	05 27       	eor	r16, r21
    3f56:	27 95       	ror	r18

00003f58 <didStuff6>:
    3f58:	00 00       	nop
    3f5a:	0b b9       	out	0x0b, r16	; 11
    3f5c:	17 95       	ror	r17
    3f5e:	1c 3f       	cpi	r17, 0xFC	; 252
    3f60:	c8 f6       	brcc	.-78     	; 0x3f14 <bitstuff6>
    3f62:	20 ff       	sbrs	r18, 0
    3f64:	05 27       	eor	r16, r21
    3f66:	27 95       	ror	r18
    3f68:	17 95       	ror	r17

00003f6a <didStuff7>:
    3f6a:	66 e0       	ldi	r22, 0x06	; 6
    3f6c:	1c 3f       	cpi	r17, 0xFC	; 252
    3f6e:	0b b9       	out	0x0b, r16	; 11
    3f70:	a0 f6       	brcc	.-88     	; 0x3f1a <bitstuff7>
    3f72:	29 91       	ld	r18, Y+
    3f74:	3a 95       	dec	r19
    3f76:	21 f7       	brne	.-56     	; 0x3f40 <txBitLoop>

00003f78 <makeSE0>:
    3f78:	09 7f       	andi	r16, 0xF9	; 249
    3f7a:	10 91 22 01 	lds	r17, 0x0122
    3f7e:	11 0f       	add	r17, r17
    3f80:	0b b9       	out	0x0b, r16	; 11
    3f82:	c6 51       	subi	r28, 0x16	; 22
    3f84:	d0 40       	sbci	r29, 0x00	; 0
    3f86:	11 f0       	breq	.+4      	; 0x3f8c <skipAddrAssign>
    3f88:	10 93 1c 01 	sts	0x011C, r17

00003f8c <skipAddrAssign>:
    3f8c:	11 e0       	ldi	r17, 0x01	; 1
    3f8e:	1c bb       	out	0x1c, r17	; 28
    3f90:	02 60       	ori	r16, 0x02	; 2
    3f92:	1a b1       	in	r17, 0x0a	; 10
    3f94:	19 7f       	andi	r17, 0xF9	; 249
    3f96:	40 2f       	mov	r20, r16
    3f98:	49 7f       	andi	r20, 0xF9	; 249
    3f9a:	53 e0       	ldi	r21, 0x03	; 3

00003f9c <se0Delay>:
    3f9c:	5a 95       	dec	r21
    3f9e:	f1 f7       	brne	.-4      	; 0x3f9c <se0Delay>
    3fa0:	00 c0       	rjmp	.+0      	; 0x3fa2 <se0Delay+0x6>
    3fa2:	0b b9       	out	0x0b, r16	; 11
    3fa4:	1a b9       	out	0x0a, r17	; 10
    3fa6:	4b b9       	out	0x0b, r20	; 11
    3fa8:	7d cf       	rjmp	.-262    	; 0x3ea4 <doReturn>

00003faa <_exit>:
    3faa:	f8 94       	cli

00003fac <__stop_program>:
    3fac:	ff cf       	rjmp	.-2      	; 0x3fac <__stop_program>
